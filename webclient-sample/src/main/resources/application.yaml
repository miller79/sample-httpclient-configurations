
spring:
  # OAuth2 client (client_credentials) example. Provide real values via environment
  # variables or a profile-specific YAML during deployment.
  security:
    oauth2:
      client:
        provider:
          serviceAccount:
            issuer-uri: ${ISSUER_URI:https://accounts.google.com}
        registration:
          serviceAccount:
            client-id: ${CLIENT_ID}
            client-secret: ${CLIENT_SECRET}
            authorization-grant-type: client_credentials

  # Reactive HTTP client section (WebClient / Reactor Netty connector)
  http:
    reactiveclient:
      # Choose the Reactor Netty connector (default for reactive clients in this sample)
      connector: reactor
      # Example timeouts (uncomment to enable):
      # connect-timeout: 10s   # Time to establish TCP connection (Reactor Netty optional)
      # read-timeout: 30s      # Maximum time to wait for read data on an established connection
      #
      # âš ï¸ NOTE: In reactive apps, timeouts work differently than blocking apps.
      # Reactive streams can produce data over time; read-timeout may not be ideal.
      # Consider using timeout operators in your reactive pipeline instead
      # (e.g., .timeout(Duration.ofSeconds(30)) on the Mono/Flux).


## Example Reactor Netty tuning (commented) ----------------------------------
# ğŸ¯ Purpose: These settings control connection pooling, lifecycle, and TCP
#            keep-alive for reactive HTTP clients (WebClient).
#
# âš ï¸ If you don't configure these: Connections live forever, reactive streams
#    can wait indefinitely, and memory can grow unbounded.
#
# ğŸ”‘ Key Difference: Reactive clients need FEWER connections than blocking
#    clients because they use non-blocking I/O. 20 connections can handle
#    thousands of concurrent reactive streams!
#
# To enable: Copy into a profile (e.g., `application-local.yaml`), remove
#           the leading `# `, and adjust values for your environment.
#
# ğŸ“– Learn more: See README.md "Understanding Timeouts & Defaults" section
#
# miller79:
#   reactor:
#     # ConnectionProvider name used in Reactor Netty (useful for metrics). Default: "connection"
#     # ğŸ’¡ Helpful when running multiple WebClient instances to distinguish metrics
#     # name: "connection"
#
#     # Maximum number of pooled connections. Default: 64
#     # ğŸ’¡ Reactive apps need FEWER connections than blocking (non-blocking I/O!)
#     # ğŸ’¡ Too low â†’ backpressure, pending acquisitions queue up
#     # ğŸ’¡ Too high â†’ memory waste, overwhelm downstream
#     # ğŸ“ Start small: 10-20 for most services, 50-100 for high throughput
#     # ğŸ“ Streaming (SSE/WebSocket): 1 connection per stream; size accordingly
#     # max-connections: 64
#
#     # Evict connections idle for longer than this. Default: 60s
#     # ğŸ’¡ Clean up unused connections to free memory and file descriptors
#     # ğŸ’¡ Should be < server idle timeout to avoid stale connections
#     # ğŸ“ Common: 30-60s (shorter if behind load balancer)
#     # max-idle-time: 60s
#
#     # Maximum lifetime of a connection before it is closed. Default: 60s
#     # ğŸ’¡ Forces connection refresh to handle DNS changes and LB timeouts
#     # ğŸ’¡ MUST be < load balancer timeout (AWS ALB=60s, Nginx=75s)
#     # ğŸ“ Common: 30-50s for LB environments, 60s for direct connections
#     # max-life-time: 60s
#
#     # Enable socket-level TCP keep-alive. Default: true
#     # ğŸ’¡ Detects broken connections in long-lived reactive streams
#     # ğŸ’¡ Especially important for SSE, WebSocket, and streaming APIs
#     # so-keep-alive: true
#
#     # Idle time before the first TCP keep-alive probe. Default: 30s
#     # âš ï¸ Linux/Epoll only! Silently ignored on Windows/Mac
#     # ğŸ’¡ Start probing after this much inactivity
#     # ğŸ“ Common: 30-60s
#     # tcp-keep-idle: 30s
#
#     # Interval between TCP keep-alive probes. Default: 5s
#     # âš ï¸ Linux/Epoll only! Silently ignored on Windows/Mac
#     # ğŸ’¡ How often to retry if first probe fails
#     # ğŸ“ Common: 5-10s
#     # tcp-keep-interval: 5s
#
#     # Number of TCP keep-alive probes before declaring connection dead. Default: 3
#     # âš ï¸ Linux/Epoll only! Silently ignored on Windows/Mac
#     # ğŸ’¡ Total detection time = tcp-keep-idle + (count Ã— interval)
#     # ğŸ“ Example: 30s + (3 Ã— 5s) = 45s to detect dead connection
#     # tcp-keep-count: 3
## -----------------------------------------------------------------------------